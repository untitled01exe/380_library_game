import java.util.ArrayList;
import java.util.Random;

public class Bookshelf {

/*Bookshelf object will:
  1.) Accept ArrayList of Strings (these will be Book objects later)
  2.) Rearrange Book positions via indices generated by a java Random (this algorithm will later be adapted to
      accommodate generation of random books)
  3.) Contain multiple sort algorithm methods to fix the disorder created by the random indexer (i.e. quicksort,
      selection sort, merge sort etc. based on STRING MATCHING [these will later be adapted to be unique book IDs] to
      see which algorithm is the most efficient for this project)

      tl;dr it's an ArrayList with custom methods
 */

    /*|||||||||||||||||[VARIABLES (PRELIMINARY)]|||||||||||||||||*/

    private String title;
    private ArrayList<String> books;


    /*||||||||||||||||||||[METHOD PROTOTYPES]||||||||||||||||||||*/

    public Bookshelf(ArrayList<String> b) {

        books = b;

    }

    public int getIndex(ArrayList<String> b) {

        int bookIndex = 0;

        for (int i = 0; i < b.size(); i++) {

            bookIndex = b.indexOf(b.get(i));
        }

        return bookIndex;
    }

    public boolean IndexChecker(int n) { //checks to see if a random has been produced before
        //return true: "this number has been produced"
        //return false: "this number has not yet been produced"

        //int temp = -1;

        //if (temp == -1) { //base case because the first passed int will never be -1 => return false

            //temp = n;
            //return false;

        //} else if (temp == n) { //if this number has been seen before, it will be equal to the temp => return true

            //return true;

        //} else { //else this is a new number; set it to the temp and return false

            //temp = n;
            //return false;
        //}

        //ArrayList<Integer> indices = new ArrayList<>();
        //indices.add(n);
        return false;
    }

    public ArrayList<Integer> AngryLibrarian(ArrayList<String> b) { //this method will eventually return a re-indexed ArrayList of Books

        Random rand = new Random();
        ArrayList<Integer> r_indices = new ArrayList<>();
        ArrayList<Integer> used = new ArrayList<>();

        while (r_indices.size() != books.size()) {

            int r = rand.nextInt(books.size()) + 1;

            if (r_indices.size() == 0) {r_indices.add(r); used.add(r);} else { //on the first iteration, add the number to both ArrayLists, else:

                if(!used.contains(r)){ //if used does not already contain the random:

                used.add(r); //add it
                r_indices.add(r); //and add it to indices

                } //otherwise the loop will keep producing randoms until r_indices is filled with unique randoms
            }
        }

        //for(int i = 0; i < books.size(); i++){
        //}

    return r_indices;
    }

    public void printer(ArrayList<Integer> b){

        for(int i = 0; i < b.size(); i++){

            System.out.println(b.get(i) - 1);
        }
    }

    //public int quickSortPartitioner(int[] ir, int l, int h){

      //  int pivotNumber = h;


        //[place swap algorithm here]

        //return i;
    //}

    //public void quickSortBookIndices(ArrayList<Integer> b, int l, int h){

        //int[] ir = null;

        //for(int i = 0; i < b.size(); i++){

            //ir[i] = b.get(i) - 1;
        //}

        //int i = quickSortPartitioner(ir, l, h); //recursively sort using partitioner helper method

    //}
}
